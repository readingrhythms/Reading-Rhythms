---

const {
  src,
  alt = "",
  width = 1200,
  class: klass = "",
  sizes = "(max-width: 768px) 100vw, (max-width: 1280px) 50vw, 600px",
  crop = "fill",
  gravity = "auto",
  quality = "auto",
  priority = false,
  heights = [],
  aspectRatio = undefined               // NEW: "16:9" or number like 16/9
} = Astro.props;

// NEW: safe transform injector (no-op for non-Cloudinary URLs)
function withTx(url: string, tx: string) {
  if (typeof url !== "string" || !url.includes("/upload/")) return url; // NEW
  return url.replace("/upload/", `/upload/${tx}/`);
}

// Width candidates (1x pattern with width descriptors)
const targetWidths = [320, 480, 640, 800, 1024, 1280, 1600].filter(
  (w) => w <= Math.max(1600, width)
);

// NEW: normalize aspect ratio
function parseAR(ar: unknown): number | undefined {
  if (!ar) return undefined;
  if (typeof ar === "number" && isFinite(ar) && ar > 0) return ar;
  if (typeof ar === "string") {
    const m = ar.trim().split(":");
    if (m.length === 2) {
      const a = Number(m[0]); const b = Number(m[1]);
      if (isFinite(a) && isFinite(b) && a > 0 && b > 0) return a / b;
    }
    const n = Number(ar);
    if (isFinite(n) && n > 0) return n;
  }
  return undefined;
}

const ar = parseAR(aspectRatio); // NEW


// NEW: compute a per-width height either from aspect ratio or heights[]
function heightForWidth(w: number, i: number): number | undefined {
  if (ar) return Math.round(w / ar);
  if (heights.length) {
    // map by index if provided; fall back to last
    return heights[Math.min(i, heights.length - 1)];
  }
  return undefined;
}

// NEW: base transformation uses dpr_auto to avoid mixing DPRs in srcset
const baseTx = (w: number, h?: number) =>
  `f_auto,q_${quality},dpr_auto,w_${w}` + (h ? `,h_${h},c_${crop},g_${gravity}` : "");

// Build srcset with width descriptors only (no DPR loop)
const srcset = targetWidths
  .map((w, i) => {
    const h = heightForWidth(w, i);            // NEW
    return `${withTx(src, baseTx(w, h))} ${w}w`;
  })
  .join(", ");

// Fallback URL at ~requested width
const fallbackW = Math.min(width, 1200);
const fallbackH = heightForWidth(fallbackW, targetWidths.indexOf(fallbackW)); // NEW
const fallback = withTx(src, baseTx(fallbackW, fallbackH));

// NEW: add width/height attributes to reduce CLS when we know them
const attrWidth = fallbackW;                   // NEW
const attrHeight = fallbackH || undefined;     // NEW
---

<img
  src={fallback}
  srcset={srcset}
  sizes={sizes}
  alt={alt}
  loading={priority ? "eager" : "lazy"}
  fetchpriority={priority ? "high" : "auto"}
  decoding="async"
  class={klass}
  width={attrWidth}                            <!-- NEW -->
  height={attrHeight}                          <!-- NEW -->
/>
